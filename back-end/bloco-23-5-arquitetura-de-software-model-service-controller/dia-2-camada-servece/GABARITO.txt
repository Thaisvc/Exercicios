Gabarito: Exerc√≠cios - agora, a pr√°tica
Exerc√≠cio 1 - Listar as pessoas motoristas (service)
Crie uma fun√ß√£o na camada Service que lista as pessoas motoristas em nosso app.

Sobre a fun√ß√£o

A fun√ß√£o deve:

Se chamar getDrivers;
Usar a camada Model para receber a lista de motoristas;
Retornar um objeto no mesmo padr√£o que as outras fun√ß√µes da nossa camada Service.
Exemplo de resposta bem sucedida

Copiar
{
  type: null,
  message: [
    { id: 1, name: 'Liana Cisneiros' },
    { id: 2, name: 'F√°bio Fraz√£o' },
    { id: 3, name: 'Anastacia Bicalho' },
    { id: 4, name: 'Samara Granjeiro' },
    { id: 5, name: 'Levi Teixeira' },
  ],
}
Parte 1.1: Crie testes unit√°rios para a fun√ß√£o getDrivers
Cen√°rios de teste

Listando as pessoas motoristas
a lista de motoristas √© um array
retorna a lista de motoristas com sucesso
Parte 1.2: Implemente a fun√ß√£o getDrivers na camada Service
Chame as fun√ß√µes da camada Model conforme a necessidade
Confirme que a fun√ß√£o passa nos testes
Parte 1.3: Crie stubs para isolar os testes
Use stubs da fun√ß√£o da camada Model para isolar seus testes
Confirme que mesmo sem um banco de dados rodando os testes funcionam corretamente
Solu√ß√£o
Lembre-se que os exerc√≠cios servem para consolidar o seu aprendizado e te ajudar a identificar as suas d√∫vidas! Portanto, √© esperado que voc√™ trave em algum momento. Somente olhe o gabarito depois de tentar resolver o problema por algum tempo!

Garanta que voc√™ entendeu tudo que est√° aqui, explique para ‚Äúa parede‚Äù para ter certeza e, se houver dificuldade, tire sua d√∫vida conosco!

No final est√° o c√≥digo finalizado do gabarito. Abaixo um passo-a-passo de uma sugest√£o de resolu√ß√£o dos exerc√≠cios.

Exerc√≠cio 1 - Listar as pessoas motoristas (service)
Parte 1.1: Crie testes unit√°rios para a fun√ß√£o getDrivers
Come√ßamos criando todos os describes e descri√ß√µes dos its para cada um dos cen√°rios de testes
Copiar
// tests/unit/services/driver-exercises.service.test.js
describe('Verificando service Driver - Exerc√≠cios', function () {
  describe('Listando as pessoas motoristas', function () {
    // TODO: ARRANGE - criar stubs para a camada Model

    it('a lista de motoristas √© um array', async function () {
      // TODO: ACT - chamar a fun√ß√£o `getDrivers`
      // TODO: ASSERT - verificar se resultado √© um array
    });

    it('retorna a lista de motoristas com sucesso', async function () {
      // TODO: ACT - chamar a fun√ß√£o `getDrivers`
      // TODO: ASSERT - verificar se resultado √© a lista de motoristas
    });
  });
});
Criamos um mock da lista de motoristas na pasta mocks
Copiar
// tests/unit/services/mocks/driver-exercises.service.mock.js
const driverList = [
  { id: 1, name: 'Liana Cisneiros' },
  { id: 2, name: 'F√°bio Fraz√£o' },
  { id: 3, name: 'Anastacia Bicalho' },
  { id: 4, name: 'Samara Granjeiro' },
  { id: 5, name: 'Levi Teixeira' },
];

module.exports = {
  driverList,
};
Criamos uma fun√ß√£o vazia na camada Service
Copiar
// src/services/driver.service.js
// ...

const getDrivers = async () => {
  // TODO: puxar motoristas do model
  // TODO: retornar objeto padronizado
};

// module.exports = {
//   getWaitingDriverTravels,
//   travelAssign,
//   startTravel,
//   endTravel,
     getDrivers,
// };
No teste, importamos a fun√ß√£o, o mock da lista, fazemos o Act e o Assert.
Copiar
// tests/unit/services/driver-exercises.service.test.js
const { expect } = require('chai');
const { driverService } = require('../../../src/services');
const { driverList } = require('./mocks/driver-exercises.service.mock');

// describe('Verificando service Driver - Exerc√≠cios', function () {
//   describe('Listando as pessoas motoristas', function () {
//     // TODO: ARRANGE - criar stubs para a camada Model
// 
//     it('a lista de motoristas √© um array', async function () {
         const travel = await driverService.getDrivers();
       
         expect(travel.message instanceof Array).to.equal(true);
//     });
// 
//     it('retorna a lista de motoristas com sucesso', async function () {
         const travel = await driverService.getDrivers();
 
         expect(travel.message).to.deep.equal(driverList);
//     });
//   });
// });
Como nesse caso n√£o temos nenhuma entrada, a parte Arrange vir√° nos stubs que trabalharemos mais tarde
Nesse momento, nossos testes est√£o falhando, mas n√£o por muito tempo!
Parte 1.2: Implemente a fun√ß√£o getDrivers na camada Service
Chamamos a camada Model para receber a lista de pessoas motoristas
Copiar
// src/services/driver.service.js
// const {
//   travelModel,
     driverModel,
// } = require('../models');

// ...

// const getDrivers = async () => {
     const drivers = await driverModel.findAll();
     return { type: null, message: drivers };
// };

// ...
Retornamos um objeto com type sendo null, indicando que deu tudo certo e message sendo a lista
Os testes agora est√£o quase passando, (podem ter mais ou menos registros na DB, por exemplo), pois ainda dependem da DB para funcionarem. ü§î
Parte 1.3: Crie stubs para isolar os testes
Finalmente criamos um stub simulando a fun√ß√£o da camada Model, isolando nossos testes! üëç
Copiar
// tests/unit/services/driver-exercises.service.test.js
// const { expect } = require('chai');
const sinon = require('sinon');

const { driverModel } = require('../../../src/models');
// const { driverService } = require('../../../src/services');
// const { driverList } = require('./mocks/driver-exercises.service.mock');

// describe('Verificando service Driver - Exerc√≠cios', function () {
//   describe('Listando as pessoas motoristas', function () {
        beforeEach(function () {
          sinon.stub(driverModel, 'findAll').resolves(driverList);
        });

        afterEach(function () {
          sinon.restore();
        });

//     it('a lista de motoristas √© um array', async function () {
// ...
Exerc√≠cio 2 - Cadastrar um carro (service)
Crie uma fun√ß√£o na camada Service que cadastra um carro em nosso app.

A fun√ß√£o deve:

Se chamar createCar;
Receber o modelo, cor e placa do novo carro;
Retornar um objeto de erro caso algum dado n√£o seja recebido ou seja inv√°lido;
Usar a camada Model para cadastrar um novo carro no banco de dados;
Retornar um objeto no mesmo padr√£o que as outras fun√ß√µes da nossa camada Service;
Par√¢metros a serem recebidos

model: string com pelo menos 3 caracteres ex: "Ford Ka"
color: string com pelo menos 2 caracteres ex.: "Azul"
licensePlate: string com exatamente 7 caracteres ex.: "ABC1D2E"
Exemplo de resposta bem sucedida

Copiar
{
  type: null,
  message: {
    id: 1,
    model: 'Chevrolet Monza',
    color: 'Branco',
    licensePlate: 'ABC1A2B',
  },
}
Exemplo de resposta de erro

Copiar
{
  type: 'INVALID_VALUE',
  message: '"model" length must be at least 3 characters long',
}
Parte 2.1: Crie testes unit√°rios para a fun√ß√£o createCar
Cen√°rios de teste

Tentando cadastrar um novo carro com erros sem√¢nticos
retorna um erro ao receber um modelo inv√°lido
retorna um erro ao receber uma cor inv√°lida
retorna um erro ao receber uma placa inv√°lida
Cadastrando um novo carro com sucesso
n√£o retorna erros
retorna o carro cadastrado
Parte 2.2: Implemente a fun√ß√£o createCar na camada Service
Crie um schema do Joi e uma fun√ß√£o de valida√ß√£o para validar os dados de um novo carro
Chame as fun√ß√µes da camada Model conforme a necessidade
Confirme que a fun√ß√£o passa nos testes
Parte 2.3: Crie stubs para isolar os testes
Use stubs da fun√ß√£o da camada Model para isolar seus testes
Confirme que mesmo sem um banco de dados rodando os testes funcionam corretamente
Solu√ß√£o
Exerc√≠cio 2 - Cadastrar um carro (service)
Parte 2.1: Crie testes unit√°rios para a fun√ß√£o createCar
Come√ßamos criando todos os describes e descri√ß√µes dos its para cada um dos cen√°rios de testes
Como vamos checar valores v√°rias vezes nos testes, criamos algumas vari√°veis globais com valores v√°lidos e inv√°lidos
Copiar
// tests/unit/services/car-exercises.service.test.js
const validModel = 'Chevrolet Monza';
const validColor = 'Branco';
const validPlate = 'ABC1A2B';
const invalidValue = '9';

describe('Verificando service Car', function () {
  describe('Tentando cadastrar um novo carro com erros sem√¢nticos', function () {     
    it('retorna um erro ao receber um modelo inv√°lido', async function () {});
    it('retorna um erro ao receber uma cor inv√°lida', async function () {});
    it('retorna um erro ao receber uma placa inv√°lida', async function () {});
  });
    
  describe('Cadastrando um novo carro com sucesso', function () {    
    it('n√£o retorna erros', async function () {});
    it('retorna o carro cadastrado', async function () {});
  });
});
Criamos um mock de um carro criado na pasta mocks
Copiar
// tests/unit/services/mocks/car-exercises.service.mock.js
const createdCar = {
  id: 1,
  model: 'Chevrolet Monza',
  color: 'Branco',
  licensePlate: 'ABC1A2B',
};

module.exports = {
  createdCar,
};
Criamos uma fun√ß√£o vazia na camada Service
Copiar
// src/services/car.service.js
const createCar = async (model, color, licensePlate) => {};

module.exports = {
  createCar,
};
Como criamos um novo m√≥dulo, temos que coloc√°-lo no index.js para simplificar a importa√ß√£o
Copiar
// src/services/index.js
   const carService = require('./car.service');
// const driverService = require('./driver.service');
// const passengerService = require('./passenger.service');
// 
// module.exports = {
     carService,
//   driverService,
//   passengerService,
// };
No teste, importamos a fun√ß√£o, o mock da lista, fazemos o Act e o Assert nos testes
üí°Dica: as mensagens aqui j√° s√£o as retornadas pelo Joi, mas como estamos usando TDD podemos come√ßar com qualquer valor e depois de implementar as valida√ß√µes podemos corrigi-las para as corretas.

Copiar
// tests/unit/services/car-exercises.service.test.js
const { expect } = require('chai');

const { carService } = require('../../../src/services');
const { createdCar } = require('./mocks/car-exercises.service.mock');

// ...

// describe('Verificando service Car', function () {
//   describe('Tentando cadastrar um novo carro com erros sem√¢nticos', function () {     
//     it('retorna um erro ao receber um modelo inv√°lido', async function () {
         const response = await carService.createCar(invalidValue, validColor, validPlate);
        
         expect(response.type).to.equal('INVALID_VALUE');
         expect(response.message).to.equal('"model" length must be at least 3 characters long');
//     });
      
//     it('retorna um erro ao receber uma cor inv√°lida', async function () {
         const response = await carService.createCar(validModel, invalidValue, validPlate);
        
         expect(response.type).to.equal('INVALID_VALUE');
         expect(response.message).to.equal('"color" length must be at least 2 characters long');
//     });
        
//     it('retorna um erro ao receber uma placa inv√°lida', async function () {
         const response = await carService.createCar(validModel, validColor, invalidValue);
        
         expect(response.type).to.equal('INVALID_VALUE');
         expect(response.message).to.equal('"licensePlate" length must be 7 characters long');
//     });
//   });
    
//   describe('Cadastrando um novo carro com sucesso', function () {      
//     it('n√£o retorna erros', async function () {
         const response = await carService.createCar(validModel, validColor, validPlate);
      
         expect(response.type).to.equal(null);
//     });
    
//     it('retorna o carro cadastrado', async function () {
         const response = await carService.createCar(validModel, validColor, validPlate);
      
         expect(response.message).to.equal(createdCar);
//     });
//   });
// });
Nossos testes est√£o falhando ‚ùå, por enquanto!
Parte 2.2: Implemente a fun√ß√£o createCar na camada Service
Adicionamos um schema do Joi e uma fun√ß√£o de valida√ß√£o para validar dados de um novo carro
Copiar
// src/services/validations/schemas-exercises.js
const Joi = require('joi');

const addCarSchema = Joi.object({
  model: Joi.string().min(3).required(),
  color: Joi.string().min(2).required(),
  licensePlate: Joi.string().length(7).required(),
});

module.exports = {
  addCarSchema,
};
Copiar
// src/services/validations/validations-exercises.js
const {
  addCarSchema,
} = require('./schemas-exercises');

const validateNewCar = (model, color, licensePlate) => {
  const { error } = addCarSchema
    .validate({ model, color, licensePlate });
 
  if (error) return { type: 'INVALID_VALUE', message: error.message };
  return { type: null, message: '' };
};

module.exports = {
  validateNewCar,
};
Adicionamos a etapa de valida√ß√£o em nossa fun√ß√£o principal
Chamamos a camada Model para cadastrar nosso carro caso esteja tudo certo
Retornamos um objeto com type sendo null, indicando que deu tudo certo e message sendo o novo carro criado
Copiar
// src/services/car.service.js
const { validateNewCar } = require('./validations/validations-exercises');
const { carModel } = require('../models');

// const createCar = async (model, color, licensePlate) => {
     const error = validateNewCar(model, color, licensePlate);
     if (error.type) return error;

     const newCar = await carModel.insert({ model, color, licensePlate });
     return { type: null, message: newCar };
// };

// ...
Os testes agora est√£o quase passando, (podem aparecer diferen√ßas na chave id no resultado, por exemplo), pois ainda est√£o dependendo do banco de dados! üò±
Parte 2.3: Crie stubs para isolar os testes
Voltando nos testes, criamos um stub simulando a fun√ß√£o da camada Model, e com isso isolamos nossos testes! üëç
S√≥ precisamos criar stubs para os testes que deveriam chamar a camada de Model
Copiar
// tests/unit/services/car-exercises.service.test.js
// const { expect } = require('chai');
const sinon = require('sinon');

const carModel = require('../../../src/models/car.model');
// ...

// describe('Cadastrando um novo carro com sucesso', function () {
    afterEach(function () {
      sinon.restore();
    });

    beforeEach(function () {
      sinon.stub(carModel, 'insert').resolves(createdCar);
    });

//  it('n√£o retorna erros', async function () {
// ...
üöÄ Exerc√≠cio 3 - Cadastrar uma pessoa motorista (service)
Crie uma fun√ß√£o na camada Service que cadastra uma pessoa motorista em nosso app.

A fun√ß√£o deve:

Se chamar createDriver;
Receber o nome da pessoa motorista;
Receber opcionalmente um array de ids de carros j√° cadastrados em nossa base de dados;
Retornar um objeto de erro caso o nome n√£o seja recebido ou seja inv√°lido;
Retornar um objeto de erro caso o array de carros seja inv√°lido ex.: algum carro n√£o exista;
Usar a camada Model para cadastrar a pessoa motorista no banco de dados;
Vincular os carros do array de ids (caso seja passada) √† pessoa motorista;
Retornar um objeto no mesmo padr√£o que as outras fun√ß√µes da nossa camada Service,
A lista de carros vinculados √† pessoa motorista deve ser retornada junto com as outras informa√ß√µes da pessoa motorista.
Par√¢metros a serem recebidos

name: string com pelo menos 3 caracteres ex: "Gena"
carIds: array com os ids dos carros a serem vinculados com a pessoa motorista (opcional)
Exemplo de resposta bem sucedida

Copiar
{
  type: null,
  message: {
    id: 1,
    name: 'Gus',
    cars: [
      {
        color: 'Branco',
        id: 1,
        licensePlate: 'NCA-0956',
        model: 'Renault Sandero',
      },
      {
        color: 'Vermelho',
        id: 2,
        licensePlate: 'DZG-4376',
        model: 'Volkswagen Gol',
      },
    ],
  }
}
Exemplo de resposta de erro

Copiar
{
  type: 'CAR_NOT_FOUND',
  message: 'Some car is not found',
}
üöÄ Parte 3.1: Crie testes unit√°rios para a fun√ß√£o createDriver
Cen√°rios de teste

Tentando cadastrar uma nova pessoa motorista com erros sem√¢nticos
retorna um erro ao receber um nome inv√°lido
retorna um erro ao receber uma lista de carros inv√°lida
Tentando cadastrar uma nova pessoa motorista com erros de id
retorna o erro ‚ÄúCAR_NOT_FOUND‚Äù
retorna a mensagem ‚ÄúSome car is not found‚Äù
Cadastrando uma nova pessoa motorista com sucesso sem carros
retorna a pessoa motorista cadastrada
n√£o retorna erro
Cadastrando uma nova pessoa motorista com sucesso com carros
retorna os carros vinculados √† pessoa motorista
n√£o retorna erro
üöÄ Parte 3.2: Implemente a fun√ß√£o createDriver na camada Service
Confirme que a fun√ß√£o passa nos testes
üöÄ Parte 3.3: Crie stubs para isolar os testes
Use stubs da fun√ß√£o da camada Model para isolar seus testes
Confirme que mesmo sem um banco de dados rodando os testes funcionam corretamente
Solu√ß√£o
üöÄ Exerc√≠cio 3 - Cadastrar uma pessoa motorista (service)
üöÄ Parte 3.1: Crie testes unit√°rios para a fun√ß√£o createDriver
Colocamos os describes e descri√ß√µes dos its para cada um dos cen√°rios de testes
Criamos algumas vari√°veis globais com valores v√°lidos e inv√°lidos
Copiar
// tests/unit/services/driver-exercises.service.test.js
// ...

const validDriverName = 'Gus';
const invalidValue = '1';

// describe('Verificando service Driver - Exerc√≠cios', function () {
  // ...
  describe('Tentando cadastrar uma nova pessoa motorista com erros sem√¢nticos', function () {
    it('retorna um erro ao receber um nome inv√°lido', async function () {});
    it('retorna um erro ao receber uma lista de carros inv√°lida', async function () {});
  });

  describe('Tentando cadastrar uma nova pessoa motorista com erros de id', function () {
    it('retorna o erro "CAR_NOT_FOUND"', async function () {});
    it('retorna a mensagem "Some car is not found"', async function () {});
  });

  describe('Cadastrando uma nova pessoa motorista com sucesso sem carros', function () {
    it('retorna a pessoa motorista cadastrada', async function () {});
    it('n√£o retorna erro', async function () {});
  });

  describe('Cadastrando uma nova pessoa motorista com sucesso com carros', function () {
    it('retorna os carros vinculados √† pessoa motorista', async function () {});
    it('n√£o retorna erro', async function () {});
  });
// ...
Adicionamos mocks para uma pessoa motorista no arquivo de mocks
Como a pessoa motorista pode ou n√£o ter uma lista de carros relacionada a ela, criamos mocks para as duas situa√ß√µes
Copiar
// tests/unit/services/mocks/driver-exercises.service.mock.js
// ...

// essas informa√ß√µes se repetem nos outros mocks e s√£o exatamente
// o que a camada Model retorna, sendo √∫til para criarmos stubs!
const createdDriver = { id: 1, name: 'Gus' };

const createdDriverWithoutCars = {
  ...createdDriver,
  cars: [],
};

const createdDriverWithCars = {
  ...createdDriver,
  cars: [
    {
      color: 'Branco',
      id: 1,
      licensePlate: 'NCA-0956',
      model: 'Renault Sandero',
    },
    {
      color: 'Vermelho',
      id: 2,
      licensePlate: 'DZG-4376',
      model: 'Volkswagen Gol',
    },
  ],
};

// module.exports = {
//   driverList,
     createdDriver,
     createdDriverWithCars,
     createdDriverWithoutCars,
// };
Criamos uma fun√ß√£o vazia na camada Service
Copiar
// src/services/driver.service.js
// ...

const createDriver = async (name, carIds) => {
  // TODO: validar dados recebidos
  // TODO: cadastrar pessoa motorista
  // TODO: se houver a array `carIds`, vincular √† pessoa motorista
  // TODO: retornar os dados da pessoa motorista
};

// module.exports = {
//   ...
     createDriver,
// };
No teste, importamos os mocks e preenchemos os testes
Copiar
// tests/unit/services/driver-exercises.service.test.js
// ...

// const {
//   driverList,
     createdDriverWithoutCars,
     createdDriverWithCars,
// } = require('./mocks/driver-exercises.service.mock');

// ...

//   describe('Tentando cadastrar uma nova pessoa motorista com erros sem√¢nticos', function () {
//     it('retorna um erro ao receber um nome inv√°lido', async function () {
         const response = await driverService.createDriver(invalidValue);

         expect(response.type).to.equal('INVALID_VALUE');
         expect(response.message).to.equal(
           '"name" length must be at least 3 characters long',
         );
//     });
//     it('retorna um erro ao receber uma lista de carros inv√°lida', async function () {
         const response = await driverService.createDriver(
           validDriverName,
           invalidValue,
         );

         expect(response.type).to.equal('INVALID_VALUE');
         expect(response.message).to.equal('"carIds" must be an array');
//     });
//   });

//   describe('Tentando cadastrar uma nova pessoa motorista com erros de id', function () {
//     it('retorna o erro "CAR_NOT_FOUND"', async function () {
         const response = await driverService.createDriver(validDriverName, [999]);

         expect(response.type).to.equal('CAR_NOT_FOUND');
//     });
    
//     it('retorna a mensagem "Some car is not found"', async function () {
         const response = await driverService.createDriver(validDriverName, [999]);

         expect(response.message).to.equal('Some car is not found');
//     });
//   });

//   describe('Cadastrando uma nova pessoa motorista com sucesso sem carros', function () {
//     it('retorna a pessoa motorista cadastrada', async function () {
         const response = await driverService.createDriver(validDriverName);
      
         expect(response.message).to.deep.equal(createdDriverWithoutCars);
//     });

//     it('n√£o retorna erro', async function () {
         const response = await driverService.createDriver(validDriverName);
      
         expect(response.type).to.equal(null);
//     });
//   });

//   describe('Cadastrando uma nova pessoa motorista com sucesso com carros', function () {
//     it('retorna os carros vinculados √† pessoa motorista', async function () {
         const response = await driverService.createDriver(
           validDriverName,
           [1, 2],
         );

         expect(response.type).to.equal(null);
         expect(response.message).to.deep.equal(createdDriverWithCars);
//     });

//     it('n√£o retorna erro', async function () {
         const response = await driverService.createDriver(
           validDriverName,
           [1, 2],
         );

         expect(response.type).to.equal(null);
//     });
//   });
// ...
Nossos testes est√£o falhando ‚ùå, mas ainda n√£o acabou!
üöÄ Parte 3.2: Implemente a fun√ß√£o createDriver na camada Service
Adicionamos um schema e a uma fun√ß√£o para validar dados para uma nova pessoa motorista
Copiar
// src/services/validations/schemas-exercises.js
// ...

// aqui reaproveitamos um dos schemas que vimos no conte√∫do
const { idSchema } = require('./schemas');

// ...

const addDriverSchema = Joi.object({
  name: Joi.string().min(3).required(),
  carIds: Joi.array().items(idSchema),
});

// module.exports = {
//   addCarSchema,
     addDriverSchema,
// };
Copiar
// src/services/validations/validations-exercises.js
const { carModel } = require('../../models');
// const {
//   addCarSchema,
     addDriverSchema,
// } = require('./schemas-exercises');

// ...

const validateNewDriver = async (name, carIds) => {
  const { error } = addDriverSchema
    .validate({ name, carIds });
  if (error) return { type: 'INVALID_VALUE', message: error.message };

  if (carIds) {
    // chamamos `carModel.findById` em cada um dos ids para buscar os carros na DB
    // quando um carro n√£o existe, sua Promise retorna `undefined`
    // `Promise.all` aguarda todas as Promises retornarem
    // e retorna a array de resultados para `cars`
    const cars = await Promise.all(
      carIds.map(async (carId) => carModel.findById(carId)),
    );

    const someCarIsMissing = cars.some((car) => car === undefined);
    if (someCarIsMissing) return { type: 'CAR_NOT_FOUND', message: 'Some car is not found' };
  }

  return { type: null, message: '' };
};

// module.exports = {
//   validateNewCar,
     validateNewDriver,
// };
Adicionamos a etapa de valida√ß√£o em nossa fun√ß√£o principal
Chamamos a camada Model para cadastrar a pessoa motorista
Copiar
// src/services/driver.service.js
// const {
//   ...
     driverCarModel,
     carModel,
// } = require('../models');

const { validateNewDriver } = require('./validations/validations-exercises');
// ...

// const createDriver = async (name, carIds) => {
     // Validando dados recebidos
     const error = await validateNewDriver(name, carIds);
     if (error.type) return error;

     // Cadastrando pessoa motorista
     const driverId = await driverModel.insert({ name });
     
     // Pegando a pessoa motorista cadastrada na DB
     const newDriver = await driverModel.findById(driverId);
    
     // Se houver a lista de ids de carros, criamos os relacionamentos
     // e adicionamos a lista ao resultado final,
     // sen√£o usamos um array vazio no lugar
     if (carIds && carIds.length > 0) {
       await Promise.all(carIds.map(
         // Usando a camada Model para vincular os carros √† pessoa motorista
         async (carId) => driverCarModel.insert({ driverId: newDriver.id, carId }),
       ));
       // Adicionamos os carros ao resultado final
       newDriver.cars = await Promise.all(
         carIds.map(async (carId) => carModel.findById(carId)),
       );
     } else {
       newDriver.cars = [];
     }
     
     // Retornando os dados da pessoa motorista
     return { type: null, message: newDriver };
// };

// module.exports = {
//   ...
     createDriver,
// };
Os testes agora est√£o quase passando, (pode haver diferen√ßas no id, por exemplo), pois ainda faltam os stubs para isol√°-los! üò±
‚ö†Ô∏è Aten√ß√£o: Observe que cada vez que essa fun√ß√£o √© executada nos testes sem os stubs ela modifica o banco de dados. Isso pode afetar outros testes caso eles n√£o estejam isolados. ‚ö°üò® Viu s√≥ como √© importante isolar os testes?
üöÄ Parte 3.3: Crie stubs para isolar os testes
Como nossa fun√ß√£o vai precisar de alguns carros, criamos um mock com uma lista deles para usarmos nos testes
Copiar
// tests/unit/services/mocks/car-exercises.service.mock.js
const carList = [
  {
    id: 1,
    model: 'Renault Sandero',
    color: 'Branco',
    licensePlate: 'NCA-0956',
  },
  {
    id: 2,
    model: 'Volkswagen Gol',
    color: 'Vermelho',
    licensePlate: 'DZG-4376',
  },
  {
    id: 3,
    model: 'Chevrolet Onix',
    color: 'Prata',
    licensePlate: 'KBJ-2899',
  },
  {
    id: 4,
    model: 'Renault Logan',
    color: 'Azul',
    licensePlate: 'NFA-9035',
  },
  {
    id: 5,
    model: 'Fiat Siena',
    color: 'Cinza',
    licensePlate: 'HTH-9177',
  },
  {
    id: 6,
    model: 'Nissan Versa',
    color: 'Preto',
    licensePlate: 'BGY-6802',
  },
];

// ...

// module.exports = {
     carList,
//   createdCar,
// };
Voltando nos testes, criamos alguns stubs da camada Model usando os mocks üëç
Esses stubs s√£o criados conforme o comportamento de cada fun√ß√£o
Copiar
// tests/unit/services/driver-exercises.service.test.js
// ...

// const {
//   driverModel,
     driverCarModel,
     carModel,
// } = require('../../../src/models');

// const { driverService } = require('../../../src/services');

const { carList } = require('./mocks/car-exercises.service.mock');

// const {
     // ...
     createdDriver,
// } = require('./mocks/driver-exercises.service.mock');

// ...

//   describe('Tentando cadastrar uma nova pessoa motorista com erros de id', function () {
       beforeEach(function () {
         // Aqui o nosso stub deve simular que o carro solicitado n√£o existe
         sinon.stub(carModel, 'findById').resolves();
       });

       afterEach(function () {
         sinon.restore();
       });

    // it('retorna o erro "CAR_NOT_FOUND"', async function () {
    // ...  

//  describe('Cadastrando uma nova pessoa motorista com sucesso sem carros', function () {
       beforeEach(function () {
         // como aqui estamos criando motorista sem carro,
         // n√£o precisamos encontrar nenhum, apenas cadastrar e encontrar a pessoa motorista
         sinon.stub(driverModel, 'insert').resolves(1);
         sinon.stub(driverModel, 'findById').resolves(createdDriver);
       });

       afterEach(function () {
         sinon.restore();
       });

    // it('retorna a pessoa motorista cadastrada', async function () {
    // ...

//   describe('Cadastrando uma nova pessoa motorista com sucesso com carros', function () {
       beforeEach(function () {
         // j√° aqui temos v√°rios stubs em cena!

         // 1 - cadastra e encontra a pessoa motorista ok
         sinon.stub(driverModel, 'insert').resolves(1);
         sinon.stub(driverModel, 'findById').resolves(createdDriver);

         // 2 - cria√ß√£o de relacionamentos ok
         sinon.stub(driverCarModel, 'insert').resolves();

         // 3 - ao procurar um carro, mande o primeiro e depois o segundo da lista
         // eles s√£o chamados tanto ao validar como para retornar na fun√ß√£o principal
         sinon.stub(carModel, 'findById')
         .onCall(0) // chamada da valida√ß√£o
           .resolves(carList[0])
         .onCall(1) // chamada da valida√ß√£o
           .resolves(carList[1])
         .onCall(2) // chamada da fun√ß√£o
           .resolves(carList[0])
         .onCall(3) // chamada da fun√ß√£o
           .resolves(carList[1]);
       });

       afterEach(function () {
         sinon.restore();
       });

    // it('retorna os carros vinculados √† pessoa motorista', async function () {
    // ...
Ufa! Se voc√™ leu tudo at√© aqui, parab√©ns! üëè Abaixo est√° o c√≥digo completo dos exerc√≠cios. N√£o esque√ßa de tomar uma √°gua! üö∞
Metadata	Value
object	content
duration	
self-contained	no
type	context
skills	[]
reinforces	[]
C√≥digo finalizado
Copiar
// tests/unit/services/driver-exercises.service.test.js
const { expect } = require('chai');
const sinon = require('sinon');

const {
  driverModel,
  driverCarModel,
  carModel,
} = require('../../../src/models');

const {
  driverService,
} = require('../../../src/services');

const {
  carList,
} = require('./mocks/car-exercises.service.mock');

const {
  driverList,
  createdDriverWithoutCars,
  createdDriverWithCars,
  createdDriver,
} = require('./mocks/driver-exercises.service.mock');

const validDriverName = 'Gus';
const invalidValue = '1';

describe('Verificando service Driver - Exerc√≠cios', function () {
  describe('Listando as pessoas motoristas', function () {
    beforeEach(function () {
      sinon.stub(driverModel, 'findAll').resolves(driverList);
    });

    afterEach(function () {
      sinon.restore();
    });
    
    it('a lista de motoristas √© um array', async function () {
      const travel = await driverService.getDrivers();

      expect(travel.message instanceof Array).to.equal(true);
    });

    it('retorna a lista de motoristas com sucesso', async function () {
      const travel = await driverService.getDrivers();

      expect(travel.message).to.deep.equal(driverList);
    });
  });

  describe('Tentando cadastrar uma nova pessoa motorista com erros sem√¢nticos', function () {
    it('retorna um erro ao receber um nome inv√°lido', async function () {
      const response = await driverService.createDriver(invalidValue);

      expect(response.type).to.equal('INVALID_VALUE');
      expect(response.message).to.equal(
        '"name" length must be at least 3 characters long',
      );
    });
    it('retorna um erro ao receber uma lista de carros inv√°lida', async function () {
      const response = await driverService.createDriver(
        validDriverName,
        invalidValue,
      );

      expect(response.type).to.equal('INVALID_VALUE');
      expect(response.message).to.equal('"carIds" must be an array');
    });
  });

  describe('Tentando cadastrar uma nova pessoa motorista com erros de id', function () {
    beforeEach(function () {
      sinon.stub(carModel, 'findById').resolves();
    });

    afterEach(function () {
      sinon.restore();
    });
    it('retorna o erro "CAR_NOT_FOUND"', async function () {
      const response = await driverService.createDriver(validDriverName, [999]);

      expect(response.type).to.equal('CAR_NOT_FOUND');
    });
    
    it('retorna a mensagem "Some car is not found"', async function () {
      const response = await driverService.createDriver(validDriverName, [999]);

      expect(response.message).to.equal('Some car is not found');
    });
  });

  describe('Cadastrando uma nova pessoa motorista com sucesso sem carros', function () {
    beforeEach(function () {
      sinon.stub(driverModel, 'insert').resolves(createdDriver);
    });

    afterEach(function () {
      sinon.restore();
    });
    it('retorna a pessoa motorista cadastrada', async function () {
      const response = await driverService.createDriver(validDriverName);
      
      expect(response.message).to.deep.equal(createdDriverWithoutCars);
    });

    it('n√£o retorna erro', async function () {
      const response = await driverService.createDriver(validDriverName);
      
      expect(response.type).to.equal(null);
    });
  });

  describe('Cadastrando uma nova pessoa motorista com sucesso com carros', function () {
    beforeEach(function () {
      sinon.stub(driverModel, 'insert').resolves(createdDriver);
      sinon.stub(driverCarModel, 'insert').resolves();
      sinon.stub(carModel, 'findById')
      .onCall(0) // chamada da valida√ß√£o
        .resolves(carList[0])
      .onCall(1) // chamada da valida√ß√£o
        .resolves(carList[1])
      .onCall(2) // chamada da fun√ß√£o
        .resolves(carList[0])
      .onCall(3) // chamada da fun√ß√£o
        .resolves(carList[1]);
    });

    afterEach(function () {
      sinon.restore();
    });

    it('retorna os carros vinculados √† pessoa motorista', async function () {
      const response = await driverService.createDriver(
        validDriverName,
        [1, 2],
      );

      expect(response.type).to.equal(null);
      expect(response.message).to.deep.equal(createdDriverWithCars);
    });

    it('n√£o retorna erro', async function () {
      const response = await driverService.createDriver(
        validDriverName,
        [1, 2],
      );

      expect(response.type).to.equal(null);
    });
  });
});
Copiar
// tests/unit/services/mocks/driver-exercises.service.mock.js
const driverList = [
  { id: 1, name: 'Liana Cisneiros' },
  { id: 2, name: 'F√°bio Fraz√£o' },
  { id: 3, name: 'Anastacia Bicalho' },
  { id: 4, name: 'Samara Granjeiro' },
  { id: 5, name: 'Levi Teixeira' },
];

const createdDriver = { id: 1, name: 'Gus' };

const createdDriverWithoutCars = {
  ...createdDriver,
  cars: [],
};

const createdDriverWithCars = {
  ...createdDriver,
  cars: [
    {
      color: 'Branco',
      id: 1,
      licensePlate: 'NCA-0956',
      model: 'Renault Sandero',
    },
    {
      color: 'Vermelho',
      id: 2,
      licensePlate: 'DZG-4376',
      model: 'Volkswagen Gol',
    },
  ],
};

module.exports = {
  driverList,
  createdDriver,
  createdDriverWithCars,
  createdDriverWithoutCars,
};
Copiar
// src/services/driver.service.js
// const {
//   travelModel,
     driverModel,
     driverCarModel,
     carModel,
// } = require('../models');
const { validateNewDriver } = require('./validations/validations-exercises');

// ...

const getDrivers = async () => {
  const drivers = await driverModel.findAll();
  return { type: null, message: drivers };
};

const createDriver = async (name, carIds) => {
  const error = await validateNewDriver(name, carIds);
  if (error.type) return error;

  const newDriver = await driverModel.insert({ name });
  
  if (carIds && carIds.length > 0) {
    await Promise.all(carIds.map(
      async (carId) => driverCarModel.insert({ driverId: newDriver.id, carId }),
    ));
    newDriver.cars = await Promise.all(
      carIds.map(async (carId) => carModel.findById(carId)),
    );
  } else {
    newDriver.cars = [];
  }

  return { type: null, message: newDriver };
};

// module.exports = {
//   getWaitingDriverTravels,
//   travelAssign,
//   startTravel,
//   endTravel,
     getDrivers,
     createDriver,
// };
Copiar
// tests/unit/services/car-exercises.service.test.js
const { expect } = require('chai');
const sinon = require('sinon');

const carModel = require('../../../src/models/car.model');
const { carService } = require('../../../src/services');
const { createdCar } = require('./mocks/car-exercises.service.mock');

const validModel = 'Chevrolet Monza';
const validColor = 'Branco';
const validPlate = 'ABC1A2B';
const invalidValue = '9';

describe('Verificando service Car', function () {
  describe('Tentando cadastrar um novo carro com erros sem√¢nticos', function () {
    it('retorna um erro ao receber um modelo inv√°lido', async function () {
      const response = await carService.createCar(invalidValue, validColor, validPlate);

      expect(response.type).to.equal('INVALID_VALUE');
      expect(response.message).to.equal(
        '"model" length must be at least 3 characters long',
      );
    });

    it('retorna um erro ao receber uma cor inv√°lida', async function () {
      const response = await carService.createCar(validModel, invalidValue, validPlate);

      expect(response.type).to.equal('INVALID_VALUE');
      expect(response.message).to.equal(
        '"color" length must be at least 2 characters long',
      );
    });

    it('retorna um erro ao receber uma placa inv√°lida', async function () {
      const response = await carService.createCar(validModel, validColor, invalidValue);

      expect(response.type).to.equal('INVALID_VALUE');
      expect(response.message).to.equal(
        '"licensePlate" length must be 7 characters long',
      );
    });
  });

  describe('Cadastrando um novo carro com sucesso', function () {
    afterEach(function () {
      sinon.restore();
    });

    beforeEach(function () {
      sinon.stub(carModel, 'insert').resolves(createdCar);
    });

    it('n√£o retorna erros', async function () {
      const response = await carService.createCar(validModel, validColor, validPlate);

      expect(response.type).to.equal(null);
    });

    it('retorna o carro cadastrado', async function () {
      const response = await carService.createCar(validModel, validColor, validPlate);

      expect(response.message).to.equal(createdCar);
    });
  });
});
Copiar
// tests/unit/services/mocks/car-exercises.service.mock.js
const carList = [
  {
    id: 1,
    model: 'Renault Sandero',
    color: 'Branco',
    licensePlate: 'NCA-0956',
  },
  {
    id: 2,
    model: 'Volkswagen Gol',
    color: 'Vermelho',
    licensePlate: 'DZG-4376',
  },
  {
    id: 3,
    model: 'Chevrolet Onix',
    color: 'Prata',
    licensePlate: 'KBJ-2899',
  },
  {
    id: 4,
    model: 'Renault Logan',
    color: 'Azul',
    licensePlate: 'NFA-9035',
  },
  {
    id: 5,
    model: 'Fiat Siena',
    color: 'Cinza',
    licensePlate: 'HTH-9177',
  },
  {
    id: 6,
    model: 'Nissan Versa',
    color: 'Preto',
    licensePlate: 'BGY-6802',
  },
];

const createdCar = {
  id: 1,
  model: 'Chevrolet Monza',
  color: 'Branco',
  licensePlate: 'ABC1A2B',
};

module.exports = {
  carList,
  createdCar,
};
Copiar
// src/services/car.service.js
const { carModel } = require('../models');
const { validateNewCar } = require('./validations/validations-exercises');

const createCar = async (model, color, licensePlate) => {
  const error = validateNewCar(model, color, licensePlate);
  if (error.type) return error;

  const newCar = await carModel.insert({ model, color, licensePlate });
  return { type: null, message: newCar };
};

module.exports = {
  createCar,
};
Copiar
// src/services/index.js
   const carService = require('./car.service');
// const driverService = require('./driver.service');
// const passengerService = require('./passenger.service');
// 
// module.exports = {
     carService,
//   driverService,
//   passengerService,
// };
Copiar
// src/services/validations/schemas-exercises.js
const Joi = require('joi');
const { idSchema } = require('./schemas');

const addCarSchema = Joi.object({
  model: Joi.string().min(3).required(),
  color: Joi.string().min(2).required(),
  licensePlate: Joi.string().length(7).required(),
});

const addDriverSchema = Joi.object({
  name: Joi.string().min(3).required(),
  carIds: Joi.array().items(idSchema),
});

module.exports = {
  addCarSchema,
  addDriverSchema,
};
Copiar
// src/services/validations/validations-exercises.js
const { carModel } = require('../../models');
const { addCarSchema, addDriverSchema } = require('./schemas-exercises');

const validateNewCar = (model, color, licensePlate) => {
  const { error } = addCarSchema
    .validate({ model, color, licensePlate });
 
  if (error) return { type: 'INVALID_VALUE', message: error.message };
  return { type: null, message: '' };
};

const validateNewDriver = async (name, carIds) => {
  const { error } = addDriverSchema
    .validate({ name, carIds });
  if (error) return { type: 'INVALID_VALUE', message: error.message };

  if (carIds) {
    // chamamos `carModel.findById` em cada um dos ids para buscar os carros na DB
    // quando um carro n√£o existe, sua Promise retorna `undefined`
    // `Promise.all` aguarda todas as Promises retornarem
    // e retorna a array de resultados para `cars`
    const cars = await Promise.all(
      carIds.map(async (carId) => carModel.findById(carId)),
    );

    const someCarIsMissing = cars.some((car) => car === undefined);
    if (someCarIsMissing) return { type: 'CAR_NOT_FOUND', message: 'Some car is not found' };
  }

  return { type: null, message: '' };
};

module.exports = {
  validateNewCar,
  validateNewDriver,
};