Gabarito: Exerc√≠cios - agora, a pr√°tica
üöÄ Exerc√≠cio 1
Crie testes unit√°rios da camada de model respons√°vel por listar todas as pessoas motoristas cadastradas no banco de dados.

Voc√™ deve verificar que:

A fun√ß√£o retorna uma estrutura de array;

Retorna a lista de pessoas motoristas com o seguinte formato:

Copiar
const expected = [
  {
    id: 1,
    name: 'Liana Cisneiros',
  }, 
  {
    id: 2,
    name: 'F√°bio Fraz√£o',
  },
];
De olho na dica üëÄ: Crie o stub da conex√£o com o banco de dados.

Crie a camada de model respons√°vel por listar todas as pessoas motoristas.
Solu√ß√£o
Parte 1
Crie testes unit√°rios da camada de model respons√°vel por listar todas as pessoas motoristas cadastradas no banco de dados.

Primeiro passo:
Agora, crie os diret√≥rios tests/unit/models, crie o arquivo driver.model.test.js e importe as depend√™ncias e crie a estrutura inicial com os describes e its.

tests/unit/models/driver.model.test.js

Copiar
const { expect } = require('chai');

describe('Driver Model', function () {
  describe('Lista todas as pessoas motoristas', function () {
    it('com o tipo array', function () {

    });

    it('com sucesso', function () {

    });
  });
});
Segundo passo:
Vamos implementar a primeira fase do TDD que √© um teste falhando. Para isso, vamos utilizar o m√©todo findAll() que ser√° implementado em um m√≥dulo que vamos criar no diret√≥rio src/models.

tests/unit/models/driver.model.test.js

Copiar
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');

describe('Driver Model', function () {
  describe('Lista todas as pessoas motoristas', function () {
    it('com o tipo array', function () {
      const response = driverModel.findAll();
    });

    it('com sucesso', function () {

    });
  });
});
Terceiro passo:
Adicione a asser√ß√£o verificando se o resultado da implementa√ß√£o √© um array.

tests/unit/models/driver.model.test.js

Copiar
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');

describe('Driver Model', function () {
  describe('Lista todas as pessoas motoristas', function () {
    it('com o tipo array', function () {
      const response = driverModel.findAll();
      expect(response).to.be.a('array');
    });

    it('com sucesso', function () {

    });
  });
});
Quarto passo:
Rode os testes e voc√™ ter√° que ao executar driverModel.findAll, ser√° disparado um erro de m√≥dulo n√£o encontrado. Agora, vamos criar o diret√≥rio src/models e criar o arquivo driver.model.js e vamos fazer uma implementa√ß√£o simples para passar nos testes da seguinte forma:

src/models/driver.model.js

Copiar
const findAll = () => [];

module.exports = {
  findAll,
};
Quinto passo:
Para facilitar as importa√ß√µes, tamb√©m criaremos um arquivo index.jsno diret√≥rio src/models em que importaremos e exportaremos o model rec√©m criado:

src/models/index.js

Copiar
const driverModel = require('./driver.model');

module.exports = {
  driverModel,
};
Sexto passo:
Passou!üéâ Legal, vamos seguir com a segunda verifica√ß√£o, pois vai refor√ßar nossa implementa√ß√£o anterior. Vamos repetir a chamada do m√©todo findAll como resposta esperada da asser√ß√£o e vamos adicionar como esse array deveria esta retornando populado pelos dados.

tests/unit/models/driver.model.test.js

Copiar
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');

describe('Driver Model', function () {
  describe('Lista todas as pessoas motoristas', function () {
    it('com o tipo array', function () {
      const response = driverModel.findAll();
      expect(response).to.be.a('array');
    });

    it('com sucesso', function () {
      const expected = [
        {
          id: 1,
          name: 'Liana Cisneiros',
        }, 
        {
          id: 2,
          name: 'F√°bio Fraz√£o',
        },
      ];

      const response = driverModel.findAll();

      expect(response).to.deep.equal(expected);
    });
  });
});
S√©timo passo:
Rode os testes e estar√° falhando novamente. Para passar, voc√™ vai precisar da implementa√ß√£o na Parte 2. Por tanto, √© l√° que vamos continuar nossa solu√ß√£o para nos auxiliar na constru√ß√£o da nossa camada de model.

Parte 2
Crie a camada de model respons√°vel por listar todas as pessoas motoristas.

Primeiro passo:
Importe o arquivo connection e utilize o m√©todo execute para implementar a query respons√°vel por localizar todas as pessoas motoristas cadastradas no banco de dados.

src/models/driver.model.js

Copiar
const connection = require('./database/connection');

const findAll = async () => {
  const [result] = await connection.execute(
  'SELECT * FROM drivers',
  );

  return result;
};

module.exports = {
  findAll,
};
Segundo passo:
Rode os testes e voc√™ ter√° todos eles falhando. Analisando a falha ela ocorreu pelos testes responderem com uma Promise e o esperado √© diferente do que implementamos nos testes, por exemplo, aguardamos que o retorno seja um array. Agora, chamamos as fun√ß√µes nos testes sem o async/await, sinal que a Promise n√£o foi tratada, vamos ajustar isso.

tests/unit/models/driver.model.test.js

Copiar
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');

describe('Driver Model', function () {
  describe('Lista todas as pessoas motoristas', function () {
    it('com o tipo array', async function () {
      const response = await driverModel.findAll();
      expect(response).to.be.a('array');
    });

    it('com sucesso', async function () {
      const expected = [
        {
          id: 1,
          name: 'Liana Cisneiros',
        }, 
        {
          id: 2,
          name: 'F√°bio Fraz√£o',
        },
      ];

      const response = await driverModel.findAll();

      expect(response).to.deep.equal(expected);
    });
  });
});
Terceiro passo:
Ao rodar os testes novamente, eles falhar√£o com o erro Error: connect ECONNREFUSED 127.0.0.1:33060. Se trata de um erro de conex√£o com o banco de dados. Ele pode n√£o acontecer caso voc√™ esteja com o servidor do MySQL online na sua m√°quina. Contudo, o ideal √© que os testes funcionem independentemente da conex√£o com o banco ser bem sucedida ou n√£o.

Para isso, utilizaremos o m√©todo stub do sinon e indicar para o connection do mysql o que o seu m√©todo execute deve retornar em caso de sucesso. Em outras palavras, estamos mockando o retorno desse m√©todo. Como isso deve ocorrer antes dos testes, utilizamos before. Importe o sinon e o m√≥dulo connection criado por voc√™ e implemente da seguinte forma:

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  describe('Lista todas as pessoas motoristas', function () {
    before(async function () {
  
      sinon.stub(connection, 'execute').resolves();
    });

    it('com o tipo array', async function () {
      const response = await driverModel.findAll();
      expect(response).to.be.a('array');
    });

    it('com sucesso', async function () {
      const expected = [
        {
          id: 1,
          name: 'Liana Cisneiros',
        }, 
        {
          id: 2,
          name: 'F√°bio Fraz√£o',
        },
      ];

      const response = await driverModel.findAll();

      expect(response).to.deep.equal(expected);
    });
  });
});
Quarto passo:
Agora, no m√©todo resolves podemos destacar o que gostar√≠amos que fosse retornado antes de executar os testes. Nesse caso, desejamos um array com os nomes das pessoas motorista, vamos implementar da seguinte forma:

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  describe('Lista todas as pessoas motoristas', function () {
    before(async function () {
      const execute = [{
          id: 1,
          name: 'Liana Cisneiros',
        },
        {
          id: 2,
          name: 'F√°bio Fraz√£o',
        },
      ];
  
      sinon.stub(connection, 'execute').resolves(execute);
    });

    it('com o tipo array', async function () {
      const response = await driverModel.findAll();
      expect(response).to.be.a('array');
    });

    it('com sucesso', async function () {
      const expected = [
        {
          id: 1,
          name: 'Liana Cisneiros',
        }, 
        {
          id: 2,
          name: 'F√°bio Fraz√£o',
        },
      ];

      const response = await driverModel.findAll();

      expect(response).to.deep.equal(expected);
    });
  });
});
Quinto passo:
Por fim, precisamos que esse stub n√£o interfira nos outros testes, por tanto vamos utilizar o after para restaurar essa conex√£o.

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  describe('Lista todas as pessoas motoristas', function () {
    before(async function () {
      const execute = [{
          id: 1,
          name: 'Liana Cisneiros',
        },
        {
          id: 2,
          name: 'F√°bio Fraz√£o',
        },
      ];
  
      sinon.stub(connection, 'execute').resolves(execute);
    });

    after(async function () {
      connection.execute.restore();
    });

    it('com o tipo array', async function () {
      const response = await driverModel.findAll();
      expect(response).to.be.a('array');
    });

    it('com sucesso', async function () {
      const expected = [
        {
          id: 1,
          name: 'Liana Cisneiros',
        }, 
        {
          id: 2,
          name: 'F√°bio Fraz√£o',
        },
      ];

      const response = await driverModel.findAll();

      expect(response).to.deep.equal(expected);
    });
  });
});
üéâ Parab√©ns seus testes passaram com sucesso!

üöÄ Exerc√≠cio 2
Crie testes unit√°rios da camada de model respons√°vel por cadastrar um carro no banco de dados.

Voc√™ deve verificar que:

Retorna o id do carro cadastrado com o seguinte formato:

Copiar
const expected = 1;
Crie a camada de model respons√°vel por cadastrar um carro.
Solu√ß√£o
Parte 1
Crie testes unit√°rios da camada de model respons√°vel por cadastrar um carro no banco de dados.

Primeiro passo:
Crie o arquivo car.model.test.js, importe as depend√™ncias e crie a estrutura inicial com o describes e its.

tests/unit/models/car.model.test.js

Copiar
const { expect } = require('chai');

describe('Car Model', function () {
  describe('Cadastra um novo carro', function () {
    it('com sucesso', function () {

    });
  });
});
Segundo passo:
Vamos implementar a primeira fase do TDD que √© um teste falhando. Para isso, vamos utilizar o m√©todo insert que ser√° implementado em um m√≥dulo que vamos criar no diret√≥rio src/models. Adicione o conte√∫do que deseja enviar para o banco como um payload.

tests/unit/models/car.model.test.js

Copiar
const { expect } = require('chai');

const { carModel } = require('../../../src/models');

describe('Car Model', function () {
  describe('Cadastra um novo carro', function () {
    const payload = {
      model: 'Renault Sandero',
      color: 'Branco',
      licensePlate: 'NCA-0956',
    };

    it('com sucesso', async function () {
      const response = await carModel.insert(payload);
    });
  });
});
Terceiro passo:
Adicione a asser√ß√£o verificando se o resultado da implementa√ß√£o corresponde ao esperado adicionado na vari√°vel expected.

tests/unit/models/car.model.test.js

Copiar
const { expect } = require('chai');

const { carModel } = require('../../../src/models');

describe('Car Model', function () {
  describe('Cadastra um novo carro', function () {
    const expected = 1;

    const payload = {
      model: 'Renault Sandero',
      color: 'Branco',
      licensePlate: 'NCA-0956',
    };

    it('com sucesso', async function () {
      const response = await carModel.insert(payload);

      expect(response).to.equal(expected);
    });
  });
});
Quarto passo:
Rode os testes e voc√™ ter√° que carModel.insert n√£o √© uma fun√ß√£o. Para passar, voc√™ vai precisar da implementa√ß√£o na Parte 2. Por tanto, √© l√° que vamos continuar nossa solu√ß√£o para nos auxiliar na constru√ß√£o da nossa camada de model.

Parte 2
Crie a camada de model respons√°vel por cadastrar um carro.

Primeiro passo:
Crie o arquivo car.model.js e vamos implementar a query para inserir no banco de dados.

src/models/car.model.js

Copiar
const connection = require('./database/connection');

const insert = async (car) => {
  await connection.execute(
  'INSERT INTO cars (model, color, license_plate) VALUE (?, ?, ?)',
  [car.model, car.color, car.licensePlate],
  );
};

module.exports = {
  insert,
};
Segundo passo:
Tamb√©m adicionaremos o novo model ao arquivo index.js:

src/models/index.js

Copiar
const driverModel = require('./driver.model');
const carModel = require('./car.model');

module.exports = {
  driverModel,
  carModel
};
Terceiro passo:
Agora, vamos desestruturar nosso resultado e retornar o insertId.

src/models/car.model.js

Copiar
const connection = require('./database/connection');

const insert = async (car) => {
  const [{ insertId }] = await connection.execute(
  'INSERT INTO cars (model, color, license_plate) VALUE (?, ?, ?)',
  [car.model, car.color, car.licensePlate],
  );

  return insertId;
};

module.exports = {
  insert,
};
Quarto passo:
Rodando os testes novamente, talvez eles falhem com o erro Error: connect ECONNREFUSED 127.0.0.1:33060 (como comentado anteriormente). Para resolver, utilizaremos o stub para simular o nosso banco da seguinte forma:

tests/unit/models/car.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { carModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Car Model', function () {
  describe('Cadastra um novo carro', function () {
    before(async function () {
      sinon.stub(connection, 'execute').resolves([]);
    });

    after(async function () {
      connection.execute.restore();
    });

    const expected = 1;

    const payload = {
      model: 'Renault Sandero',
      color: 'Branco',
      licensePlate: 'NCA-0956',
    };

    it('com sucesso', async function () {
      const response = await carModel.insert(payload);

      expect(response).to.equal(expected);
    });
  });
});
Quinto passo:
Rode os testes, obter√° a falha que n√£o √© poss√≠vel ler a propriedade insertId. Vamos utilizar a vari√°vel execute para simular esse retorno que seria o papel do banco de dados. Veja a seguir:

tests/unit/models/car.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { carModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Car Model', function () {
  describe('Cadastra um novo carro', function () {
    before(async function () {
      const execute = { insertId: 1 };

      sinon.stub(connection, 'execute').resolves([execute]);
    });

    after(async function () {
      connection.execute.restore();
    });

    const expected = 1;

    const payload = {
      model: 'Renault Sandero',
      color: 'Branco',
      licensePlate: 'NCA-0956',
    };

    it('com sucesso', async function () {
      const response = await carModel.insert(payload);

      expect(response).to.equal(expected);
    });
  });
});
üéâ Parab√©ns seus testes passaram com sucesso!

üöÄ Exerc√≠cio 3
Crie testes unit√°rios da camada de model respons√°vel por encontrar um carro por meio do id.

Voc√™ deve verificar que:

Retorna o carro solicitado pelo id com o seguinte formato:

Copiar
const expected = {
  id: 2,
  model: 'Volkswagen Gol',
  color: 'Vermelho',
  licensePlate: 'DZG-4376',
};
Crie a camada de model respons√°vel por encontrar um carro por meio do id.
Solu√ß√£o
Parte 1
Crie testes unit√°rios da camada de model respons√°vel por encontrar um carro por meio do id. Observa√ß√£o: os testes anteriores estar√£o omitidos apenas para facilitar a visualiza√ß√£o.

Primeiro passo:
No arquivo car.model.test.js, adicione mais uma estrutura de describes e its referentes ao recurso que testaremos agora.

tests/unit/models/car.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { carModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Car Model', function () {
  /* Testes anteriores aqui... */

  describe('Encontra um carro pelo id', function () {
    it('com sucesso', function () {

    });
  });
});
Segundo passo:
Vamos implementar a primeira fase do TDD que √© um teste falhando. Para isso, vamos utilizar o m√©todo findById que ser√° implementado no m√≥dulo src/models/car.model.js. Adicione o id que deseja encontrar em um payload.

tests/unit/models/car.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { carModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Car Model', function () {
  /* Testes anteriores aqui... */

  describe('Encontra um carro pelo id', function () {
    const payload = 2;

    it('com sucesso', async function () {
      const response = await carModel.findById(payload);
    });
  });
});
Terceiro passo:
Adicione a asser√ß√£o verificando se o resultado da implementa√ß√£o corresponde ao esperado adicionado na vari√°vel expected.

tests/unit/models/car.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { carModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Car Model', function () {
  /* Testes anteriores aqui... */

  describe('Encontra um carro pelo id', function () {
    const expected = {
      id: 2,
      model: 'Volkswagen Gol',
      color: 'Vermelho',
      licensePlate: 'DZG-4376',
    };

    const payload = 2;

    it('com sucesso', async function () {
      const response = await carModel.findById(payload);

      expect(response).to.deep.equal(expected);
    });
  });
});
Quarto passo:
Rode os testes e voc√™ ter√° que carModel.findById n√£o √© uma fun√ß√£o. Para passar, voc√™ vai precisar da implementa√ß√£o na Parte 2. Por tanto, √© l√° que vamos continuar nossa solu√ß√£o para nos auxiliar na constru√ß√£o da nossa camada de model.

Parte 2
Crie a camada de model respons√°vel por encontrar um carro por meio do id. Observa√ß√£o: os testes e fun√ß√µes anteriores estar√£o omitidos apenas para facilitar a visualiza√ß√£o.

Primeiro passo:
No arquivo car.model.js, vamos implementar a query para buscar o id no banco de dados.

src/models/car.model.js

Copiar
const connection = require('./database/connection');

const insert = async (car) => {
  const [{ insertId }] = await connection.execute(
  'INSERT INTO cars (model, color, license_plate) VALUE (?, ?, ?)',
  [car.model, car.color, car.licensePlate],
  );

  return insertId;
};

/* Nova fun√ß√£o */
const findById = async (carId) => {
  await connection.execute(
  'SELECT * FROM cars WHERE id = ?',
  [carId],
  );
};

module.exports = {
  insert,
  findById,
};
Segundo passo:
Agora, vamos desestruturar nosso resultado e retornar somente o primeiro elemento. Vamos utilizar o camelize para converter os resultados que usarem snake_case.

src/models/car.model.js

Copiar
/* Importe o m√≥dulo camelize */
const camelize = require('camelize');
const connection = require('./database/connection');

/* Fun√ß√µes anteriores aqui... */

const findById = async (carId) => {
  const [[result]] = await connection.execute(
  'SELECT * FROM cars WHERE id = ?',
  [carId],
  );

 return camelize(result);
};

/* Restante do arquivo... */
Terceiro passo:
Rodando os testes novamente, talvez eles falhem com o erro Error: connect ECONNREFUSED 127.0.0.1:33060 (como comentado anteriormente). Para resolver, utilizaremos o stub para simular o nosso banco da seguinte forma:

tests/unit/models/car.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { carModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Car Model', function () {
  /* Testes anteriores aqui... */

  describe('Encontra um carro pelo id', function () {
    before(async function () {
      const execute = [
        {
          id: 2,
          model: 'Volkswagen Gol',
          color: 'Vermelho',
          license_plate: 'DZG-4376',
        },
      ];
  
      sinon.stub(connection, 'execute').resolves([execute]);
    });
  
    after(async function () {
      connection.execute.restore();
    });

    const expected = {
      id: 2,
      model: 'Volkswagen Gol',
      color: 'Vermelho',
      licensePlate: 'DZG-4376',
    };

    const payload = 2;

    it('com sucesso', async function () {
      const response = await carModel.findById(payload);

      expect(response).to.deep.equal(expected);
    });
  });
});
üéâ Parab√©ns seus testes passaram com sucesso!

üöÄ Exerc√≠cio 4
Crie testes unit√°rios da camada de model respons√°vel por encontrar uma pessoa motorista por meio do id.

Voc√™ deve verificar que:

Retorna a pessoa motorista solicitado pelo id com o seguinte formato:

Copiar
const expected = {
  id: 1,
  name: 'Liana Cisneiros',
};
Crie a camada de model respons√°vel por encontrar uma pessoas motorista por meio do id.
Solu√ß√£o
Parte 1
Crie testes unit√°rios da camada de model respons√°vel por encontrar uma pessoa motorista por meio do id. Observa√ß√£o: os testes anteriores estar√£o omitidos apenas para facilitar a visualiza√ß√£o.

Primeiro passo:
No arquivo driver.model.test.js, adicione mais uma estrutura de describes e its referentes ao recurso que testaremos agora.

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  /* Testes anteriores aqui... */

  describe('Encontra uma pessoa motorista pelo id', function () {
    it('com sucesso', function () {

    });
  });
});
Segundo passo:
Vamos implementar a primeira fase do TDD que √© um teste falhando. Para isso, vamos utilizar o m√©todo findById que ser√° implementado no m√≥dulo src/models/driver.model.js. Adicione o id que deseja encontrar em um payload.

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  /* Testes anteriores aqui... */

  describe('Encontra uma pessoa motorista pelo id', function () {
    const payload = 2;

    it('com sucesso', async function () {
      const response = await driverModel.findById(payload);
    });
  });
});
Terceiro passo: Adicione a asser√ß√£o verificando se o resultado da implementa√ß√£o corresponde ao esperado adicionado na vari√°vel expected
tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  /* Testes anteriores aqui... */

  describe('Encontra uma pessoa motorista pelo id', function () {
    const expected = {
      id: 2,
      name: 'F√°bio Fraz√£o',
    };

    const payload = 2;

    it('com sucesso', async function () {
      const response = await driverModel.findById(payload);

      expect(response).to.deep.equal(expected);
    });
  });
});
Quarto passo:
Rode os testes e voc√™ ter√° que driverModel.findById n√£o √© uma fun√ß√£o. Para passar, voc√™ vai precisar da implementa√ß√£o na Parte 2. Por tanto, √© l√° que vamos continuar nossa solu√ß√£o para nos auxiliar na constru√ß√£o da nossa camada de model.

Parte 2
Crie a camada de model respons√°vel por encontrar uma pessoas motorista por meio do id. Observa√ß√£o: os testes e fun√ß√µes anteriores estar√£o omitidos apenas para facilitar a visualiza√ß√£o.

Primeiro passo:
No arquivo driver.model.js, vamos implementar a query para buscar o id no banco de dados.

src/models/driver.model.js

Copiar
const connection = require('./database/connection');

const findAll = async () => {
  const [result] = await connection.execute(
  'SELECT * FROM drivers',
  );

  return result;
};

/* Nova fun√ß√£o */
const findById = async (driverId) => {
  await connection.execute(
  'SELECT * FROM drivers WHERE id = ?',
  [driverId],
  );
};

module.exports = {
  findAll,
  findById,
};
Segundo passo:
Agora, vamos desestruturar nosso resultado e retornar somente o primeiro elemento.

src/models/driver.model.js

Copiar
const connection = require('./database/connection');

/* Fun√ß√µes anteriores aqui... */

const findById = async (driverId) => {
  const [[result]] = await connection.execute(
  'SELECT * FROM drivers WHERE id = ?',
  [driverId],
  );

  return result;
};

/* Restante do arquivo... */
Terceiro passo:
Rodando os testes novamente, talvez eles falhem com o erro Error: connect ECONNREFUSED 127.0.0.1:33060 (como comentado anteriormente). Para resolver, utilizaremos o stub para simular o nosso banco da seguinte forma:

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  /* Testes anteriores aqui... */

  describe('Encontra uma pessoa motorista pelo id', function () {
    before(async function () {
      const execute = [
        {
          id: 2,
          name: 'F√°bio Fraz√£o',
        },
      ];

      sinon.stub(connection, 'execute').resolves([execute]);
    });
  
    after(async function () {
      connection.execute.restore();
    });

    const expected = {
      id: 2,
      name: 'F√°bio Fraz√£o',
    };

    const payload = 2;

    it('com sucesso', async function () {
      const response = await driverModel.findById(payload);

      expect(response).to.deep.equal(expected);
    });
  });
});
üéâ Parab√©ns seus testes passaram com sucesso!

üöÄ Exerc√≠cio 5
Crie testes unit√°rios da camada de model respons√°vel por cadastrar uma pessoa motorista.

Voc√™ deve verificar que:

Retorna a pessoa motorista cadastrada com o seguinte formato:

Copiar
const expected = 1;
Crie a camada de model respons√°vel por cadastrar uma pessoa motorista.
Solu√ß√£o
Parte 1
Crie testes unit√°rios da camada de model respons√°vel por criar o relacionamento N:N entre as pessoas motoristas e os carros. Observa√ß√£o: os testes anteriores estar√£o omitidos apenas para facilitar a visualiza√ß√£o.

Primeiro passo:
No arquivo driver.model.test.js, adicione mais uma estrutura de describes e its referentes ao recurso que testaremos agora.

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  /* Testes anteriores aqui... */

  describe('Cadastra uma pessoa motorista', function () {
    it('com sucesso', function () {
    });
  });
});
Segundo passo:
Vamos implementar a primeira fase do TDD que √© um teste falhando. Para isso, vamos utilizar o m√©todo insert que ser√° implementado no m√≥dulo src/models/driver.model.js. Adicione o conte√∫do que deseja enviar para o banco como um payload.

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  /* Testes anteriores aqui... */

  describe('Cadastra uma pessoa motorista', function () {
    it('com sucesso', async function () {
      const payload = {
        name: 'Liana Cisneiros',
      };

      const response = await driverModel.insert(payload);
    });
  });
});
Terceiro passo:
Adicione a asser√ß√£o verificando se o resultado da implementa√ß√£o corresponde ao esperado adicionado na vari√°vel expected.

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  /* Testes anteriores aqui... */

  describe('Cadastra uma pessoa motorista', function () {
    it('com sucesso', async function () {
      const expected = 1;

      const payload = {
        name: 'Liana Cisneiros',
      };

      const response = await driverModel.insert(payload);

      expect(response).to.equal(expected);
    });
  });
});
Quarto passo:
Rode os testes e voc√™ ter√° que driverModel.insert n√£o √© uma fun√ß√£o. Para passar, voc√™ vai precisar da implementa√ß√£o na Parte 2. Por tanto, √© l√° que vamos continuar nossa solu√ß√£o para nos auxiliar na constru√ß√£o da nossa camada de model.

Parte 2
Crie a camada de model respons√°vel por cadastrar uma pessoa motorista. Observa√ß√£o: os testes e fun√ß√µes anteriores estar√£o omitidos apenas para facilitar a visualiza√ß√£o.

Primeiro passo:
No arquivo driver.model.js, vamos implementar a query para inserir no banco de dados.

src/models/driver.model.js

Copiar
const connection = require('./database/connection');

const findAll = async () => {
  const [result] = await connection.execute(
  'SELECT * FROM drivers',
  );

  return result;
};

const findById = async (driverId) => {
  const [[result]] = await connection.execute(
  'SELECT * FROM drivers WHERE id = ?',
  [driverId],
  );

  return result;
};

/* Nova fun√ß√£o */
const insert = async (driver) => {
  await connection.execute(
  'INSERT INTO drivers (name) VALUE (?)',
  [driver.name],
  );
};

module.exports = {
  findAll,
  findById,
  insert,
};
Segundo passo:
Agora, vamos desestruturar nosso resultado e retornar o insertId.

src/models/driver.model.js

Copiar
/* Fun√ß√µes anteriores aqui... */

const insert = async (driver) => {
  const [{ insertId }] = await connection.execute(
  'INSERT INTO drivers (name) VALUE (?)',
  [driver.name],
  );

  return insertId;
};

/* Restante do arquivo... */
Terceiro passo:
Rodando os testes novamente, talvez eles falhem com o erro Error: connect ECONNREFUSED 127.0.0.1:33060 (como comentado anteriormente). Para resolver, utilizaremos o stub para simular o nosso banco da seguinte forma:

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  /* Testes anteriores aqui... */

  describe('Cadastra uma pessoa motorista', function () {
    before(async function () {
      sinon.stub(connection, 'execute').resolves([]);
    });
  
    after(async function () {
      connection.execute.restore();
    });

    it('com sucesso', async function () {
      const expected = 1;

      const payload = {
        name: 'Liana Cisneiros',
      };

      const response = await driverModel.insert(payload);

      expect(response).to.equal(expected);
    });
  });
});
Quarto passo:
Rode os testes, obter√° a falha que n√£o √© poss√≠vel ler a propriedade insertId. Vamos utilizar a vari√°vel execute para simular esse retorno que seria o papel do banco de dados. Veja a seguir:

tests/unit/models/driver.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver Model', function () {
  /* Testes anteriores aqui... */

  describe('Cadastra uma pessoa motorista', function () {
    before(async function () {
      const execute = { insertId: 1 };

      sinon.stub(connection, 'execute').resolves([execute]);
    });
  
    after(async function () {
      connection.execute.restore();
    });

    it('com sucesso', async function () {
      const expected = 1;

      const payload = {
        name: 'Liana Cisneiros',
      };

      const response = await driverModel.insert(payload);

      expect(response).to.equal(expected);
    });
  });
});
üéâ Parab√©ns seus testes passaram com sucesso!

üöÄ Exerc√≠cio 6
Crie testes unit√°rios da camada de model respons√°vel por criar o relacionamento N:N entre as pessoas motoristas e os carros.

Voc√™ deve verificar que:

Retorna o relacionamento entre motorista e carro cadastrado com o seguinte formato:

Copiar
const expected = 1;
Crie a camada de model respons√°vel por cadastrar as pessoas motoristas com o relacionamento N:N com os carros cadastrados.
Solu√ß√£o
Parte 1
Crie testes unit√°rios da camada de model respons√°vel por criar o relacionamento N:N entre as pessoas motoristas e os carros.

Primeiro passo:
Crie o arquivo driver_car.model.test.js, importe as depend√™ncias e crie a estrutura inicial com o describes e its.

tests/unit/models/driver_car.model.test.js

Copiar
const { expect } = require('chai');

describe('Driver_Car Model', function () {
  describe('Cadastra o relacionamento das pessoas motoristas com os carros', function () {
    it('com sucesso', async function () {
    });
  });
});
Segundo passo:
Vamos implementar a primeira fase do TDD que √© um teste falhando. Para isso, vamos utilizar o m√©todo insert que ser√° implementado em um m√≥dulo que vamos criar no diret√≥rio src/models. Adicione o conte√∫do que deseja enviar para o banco como um payload.

tests/unit/models/driver_car.model.test.js

Copiar
const { expect } = require('chai');

const { driverCarModel } = require('../../../src/models');

describe('Driver_Car Model', function () {
  describe('Cadastra o relacionamento das pessoas motoristas com os carros', function () {
    it('com sucesso', async function () {
      const payload = {
        driverId: 3,
        carId: 1,
      };

      const response = await driverCarModel.insert(payload);
    });
  });
});
Terceiro passo:
Adicione a asser√ß√£o verificando se o resultado da implementa√ß√£o corresponde ao esperado adicionado na vari√°vel expected.

tests/unit/models/driver_car.model.test.js

Copiar
const { expect } = require('chai');

const { driverCarModel } = require('../../../src/models');

describe('Driver_Car Model', function () {
  describe('Cadastra o relacionamento das pessoas motoristas com os carros', function () {
    it('com sucesso', async function () {
      const expected = 1;

      const payload = {
        driverId: 3,
        carId: 1,
      };

      const response = await driverCarModel.insert(payload);

      expect(response).to.equal(expected);
    });
  });
});
Quarto passo:
Rode os testes e voc√™ ter√° que driverCarModel.insert n√£o √© uma fun√ß√£o. Para passar, voc√™ vai precisar da implementa√ß√£o na Parte 2. Por tanto, √© l√° que vamos continuar nossa solu√ß√£o para nos auxiliar na constru√ß√£o da nossa camada de model.

Parte 2
Crie a camada de model respons√°vel por cadastrar as pessoas motoristas com o relacionamento N:N com os carros cadastrados.

Primeiro passo:
Crie o arquivo driver_car.model.js e vamos implementar a query para inserir no banco de dados.

src/models/driver_car.model.js

Copiar
const connection = require('./database/connection');

const insert = async (driverCar) => {
  await connection.execute(
  'INSERT INTO drivers_cars (driver_id, car_id) VALUE (?, ?)',
  [driverCar.driverId, driverCar.carId], 
  );
};

module.exports = {
  insert,
};
Segundo passo:
Tamb√©m adicionaremos o novo model ao arquivo index.js:

src/models/index.js

Copiar
const driverModel = require('./driver.model');
const carModel = require('./car.model');
const driverCarModel = require('./driver_car.model');

module.exports = {
  driverModel,
  carModel,
  driverCarModel,
};
Terceiro passo:
Agora, vamos desestruturar nosso resultado e retornar o insertId.

src/models/driver_car.model.js

Copiar
const connection = require('./database/connection');

const insert = async (driverCar) => {
  const [{ insertId }] = await connection.execute(
  'INSERT INTO drivers_cars (driver_id, car_id) VALUE (?, ?)',
  [driverCar.driverId, driverCar.carId], 
  );

  return insertId;
};

module.exports = {
  insert,
};
Quarto passo:
Rodando os testes novamente, talvez eles falhem com o erro Error: connect ECONNREFUSED 127.0.0.1:33060 (como comentado anteriormente). Para resolver, utilizaremos o stub para simular o nosso banco da seguinte forma:

tests/unit/models/driver_car.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverCarModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver_Car Model', function () {
  describe('Cadastra o relacionamento das pessoas motoristas com os carros', function () {
    before(async function () {
      sinon.stub(connection, 'execute').resolves([]);
    });
  
    after(async function () {
      connection.execute.restore();
    });

    it('com sucesso', async function () {
      const expected = 1;

      const payload = {
        driverId: 3,
        carId: 1,
      };

      const response = await driverCarModel.insert(payload);

      expect(response).to.equal(expected);
    });
  });
});
Quinto passo:
Rode os testes, obter√° a falha que n√£o √© poss√≠vel ler a propriedade insertId. Vamos utilizar a vari√°vel execute para simular esse retorno que seria o papel do banco de dados. Veja a seguir:

tests/unit/models/driver_car.model.test.js

Copiar
const sinon = require('sinon');
const { expect } = require('chai');

const { driverCarModel } = require('../../../src/models');
const connection = require('../../../src/models/database/connection');

describe('Driver_Car Model', function () {
  describe('Cadastra o relacionamento das pessoas motoristas com os carros', function () {
    before(async function () {
      const execute = { insertId: 1 };

      sinon.stub(connection, 'execute').resolves([execute]);
    });
  
    after(async function () {
      connection.execute.restore();
    });

    it('com sucesso', async function () {
      const expected = 1;

      const payload = {
        driverId: 3,
        carId: 1,
      };

      const response = await driverCarModel.insert(payload);

      expect(response).to.equal(expected);
    });
  });
});
üéâ Parab√©ns seus testes passaram com sucesso!